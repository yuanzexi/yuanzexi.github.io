# 【学习笔记】SSE指令集

----

[TOC]

----

## 什么是SSE指令集
SIMD（Single Instruction，Multiple Data），一条指令操作多个数据。是CPU基本指令集的扩展。主要用于提供fine grain parallelism，即小碎数据的并行操作。比如说图像处理，图像的数据常用的数据类型是RGB565, RGBA8888, YUV422等格式，这些格式的数据特点是一个像素点的一个分量总是用小于等于8 bit的数据表示的。如果使用传统的处理器做计算，虽然处理器的寄存器是32位或是64位的，处理这些数据确只能用于他们的低8位，似乎有点浪费。如果把64位寄存器拆成8个8位寄存器就能同时完成8个操作，计算效率提升了8倍。SIMD指令的初衷就是这样的，只不过后来慢慢cover的功能越来越多。好多处理器都有SIMD指令，我们先仅关注Intel的SIMD。

### 发展历史

![title](/assets/image/sse/sse_history.png)

Intel的初代SIMD指令集是[MMX](https://zh.wikipedia.org/wiki/MMX)（Multi-Media Extension, 即多媒体扩展）到后来基于MMX升级开发了[SSE](https://zh.wikipedia.org/wiki/SSE)（Streaming SIMD Extensions），然后一直迭代更新到SSE4。直至2010年，Intel全新发布推出了Intel [AVX](https://zh.wikipedia.org/wiki/AVX%E6%8C%87%E4%BB%A4%E9%9B%86)（Advanced Vector Extensions）指令扩展集。AVX指令集是Sandy Bridge和Larrabee架构下的新指令集。AVX是在之前的128位扩展到和256位的单指令多数据流。而Sandy Bridge的单指令多数据流演算单元扩展到256位的同时数据传输也获得了提升，所以从理论上看CPU内核浮点运算性能提升到了2倍。
Intel AVX指令集，在单指令多数据流计算性能增强的同时也沿用了的MMX/SSE指令集。不过和MMX/SSE的不同点在于增强的AVX指令，从指令的格式上就发生了很大的变化。x86(IA-32/Intel 64)架构的基础上增加了prefix(Prefix)，所以实现了新的命令，也使更加复杂的指令得以实现，从而提升了x86 CPU的性能。

### SSE指令集简介

Intel公司的单指令多数据流式扩展（SSE，Streaming SIMD Extensions）技术能够有效增强CPU浮点运算的能力。
SSE本质上类似于一个向量处理器，包括了4个主要部分：单精确度浮点数运算指令、整数运算指令(为MMX的延伸，并与MMX使用同样的暂存器)、Cache控制指令、状态控制指令。
SSE浮点运算指令分为两大类：packed和scalar
packed指令是一次对XMM暂存器中的四个浮点数(DATA0~DATA3)均进行计算，而scalar只对XMM暂存器中的DATA0进行计算，见下图。

![title](/assets/image/sse/sse_flow_1.png)       
![title](/assets/image/sse/sse_flow_2.png)

SSE指令的一般格式由三部分组成，第一部分表示指令的作用，第二部分是s或者p分别表示scalar或packed，第三部分为s，表示单精度浮点数(single precision floating point data)

SSE定址/寻址方式：
SSE指令和一般的x86指令很类似，基本包括两种定址方式：寄存器－寄存器方式(reg-reg)和寄存器－内存方式(reg-mem):

```c
addps xmm0,xmm1;reg-reg
addps xmm0,[ebx]; reg-mem
```

### 编程及CPU支持性

Visual Studio .NET 2003提供了对SSE指令集的编程支持，从而允许用户在C++代码中不用编写汇编代码就可直接使用SSE指令的功能。在Linux下可以使用cat /proc/cpuinfo来查看CPU支持哪些指令集。SSE的指令集是X86架构CPU特有的，对于ARM架构、MIPS架构等CPU是不支持的，所以使用了SSE指令集的程序，是不具备可移植标准的。

## 为什么要用SSE指令集

SSE是一种数据并行处理技术，能够在一条指令中同时对多个数据执行运算操作，增加处理器的数据吞吐量，特别适用于像信号处理、科学计算或者3D图形计算等这类数据密集型运算。其优势包括：更高分辨率的图像浏览和处理、高质量音频、MPEG2视频、同时MPEG2加解密；语音识别占用更少CPU资源；更高精度和更快响应速度。
考虑一下下面这个任务：计算一个很长的浮点型数组中每一个元素的平方根。实现这个任务的算法可以这样写：

```python
for each f in array        //对数组中的每一个元素
    f = sqrt(f)             //计算它的平方根
```

为了了解实现的细节，我们把上面的代码这样写：

```python
for each f in array
{
    把f从内存加载到浮点寄存器
    计算平方根
    再把计算结果从寄存器中取出放入内存
}
```

具有Intel SSE指令集支持的处理器有8个128位的寄存器，每一个寄存器可以存放4个（32位）单精度的浮点数。SSE同时提供了一个指令集，其中的指令可以允许把浮点数加载到这些128位的寄存器之中，这些数就可以在这些寄存器中进行算术逻辑运算，然后把结果放回内存。采用SSE技术后，算法可以写成下面的样子：

```python
for each  4 members in array  //对数组中的每4个元素
{
    把数组中的这4个数加载到一个128位的SSE寄存器中
    在一个CPU指令执行周期中完成计算这4个数的平方根的操作
    把所得的4个结果取出写入内存
}
```

C++编程人员在使用SSE指令函数编程时不必关心这些128位的寄存器，你可以使用128位的数据类型“__m128”和一系列C++函数来实现这些算术和逻辑操作，而决定程序使用哪个SSE寄存器以及代码优化是C++编译器的任务。当需要对很长的浮点数数组中的元素进行处理的时候，SSE技术确实是一种很高效的方法。

## SSE指令集使用简介

SSE指令有三种方法:

1. 最简单的方法就是我们写C/C++代码，让编译器自己转化。写代码的时候遵守某些规则可以帮助编译器尽量吧。
2. 使用编译器提供的intrinsic，即编译器实现了一些内置函数和类型，使用它们的时候，对应的操作会翻译成SIMD指令。
3. 写汇编代码或是C语言嵌入汇编代码。

### SSE程序设计详细介绍

- 包含的头文件
所有的SSE指令函数和__m128数据类型都在xmmintrin.h文件中定义：

```c++
#include <xmmintrin.h>
```

因为程序中用到的SSE处理器指令是由编译器决定，所以它并没有相关的.lib库文件。
- 数据分组
由SSE指令处理的每一个浮点数数组必须把其中需要处理的数每16个字节（128位二进制）分为一组。一个静态数组（static array）可由`__declspec(align(16))`关键字声明：

```c++
__declspec(align(16)) float m_fArray[ARRAY_SIZE];
```

动态数组（dynamic array）可由`_aligned_malloc`函数为其分配空间：

```c++
m_fArray = (float*) _aligned_malloc(ARRAY_SIZE * sizeof(float), 16);
```

由`_aligned_malloc`函数分配空间的动态数组可以由`_aligned_free`函数释放其占用的空间：

```c++
_aligned_free(m_fArray);
```

- __m128数据类型
该数据类型的变量可用做SSE指令的操作数，它们不能被用户指令直接存取。_m128类型的变量被自动分配为16个字节的字长。
- CPU对SSE指令集的支持
如果你的CPU能够具有了SSE指令集，你就可以使用Visual Studio .NET 2003提供的对SSE指令集支持的C++函数库了，你可以查看MSDN中的一个Visual C++ CPUID的例子[4]，它可以帮你检测你的CPU是否支持SSE、MMX指令集或其它的CPU功能。

### 编程实例

以下讲解了SSE技术在Visual Studio .NET 2003下的应用实例，你可以在http://www.codeproject.com/cpp/sseintro/SSE_src.zip下载示例程序压缩包。该压缩包中含有两个项目，这两个项目是基于微软基本类库（MFC）建立的Visual C++.NET项目，你也可以按照下面的讲解建立这两个项目。

#### SSETest 示例项目

SSETest项目是一个基于对话框的应用程序，它用到了三个浮点数组参与运算：

```c++
fResult[i] = sqrt( fSource1[i]*fSource1[i] + fSource2[i]*fSource2[i] ) + 0.5
```

其中i = 0, 1, 2 ... ARRAY_SIZE-1

其中ARRAY_SIZE被定义为300000。数据源数组（Source数组）通过使用随机正太分布函数给它赋值。计算所需的时间(以毫秒ms为单位)在对话框中显示出来。我们使用三种不同的途径来完成计算：

- 纯C++代码
- 使用Visual C++.NET的 SSE指令函数的代码
- 包含SSE汇编指令的代码

为了查询使用SSE指令C++函数的方法，我参考了Intel软件说明书（Intel Software manuals）中有关SSE汇编指令的说明，首先我是在第一卷的第九章找到的相关SSE指令，然后在第二卷找到了这些SSE指令的详细说明，这些说明有一部分涉及了与其特性相关的C++函数。然后我通过这些SSE指令对应的C++函数查找了MSDN中与其相关的说明。搜索的结果见下表:     

|实现的功能|对应的SSE汇编指令	| Visual C++.NET中的SSE函数 |
|---|---|---|
|将4个32位浮点数放进一个128位的存储单元。	|movss 和 shufps	|_mm_set_ps1|
|将4对32位浮点数同时进行相乘操作。这4对32位浮点数来自两个128位的存储单元，再把计算结果（乘积）赋给一个128位的存储单元。	|mulps	|_mm_mul_ps|
|将4对32位浮点数同时进行相加操作。这4对32位浮点数来自两个128位的存储单元，再把计算结果（相加之和）赋给一个128位的存储单元。	|addps	|_mm_add_ps|
|对一个128位存储单元中的4个32位浮点数同时进行求平方根操作。	|sqrtps	|_mm_sqrt_ps|

代码如下:

```c++
#include <iostream>
#include <bitset>
#include <chrono>
#include <vector>
#include <random>
#include <emmintrin.h>

/**
 * 1. 纯C++代码
 */
void ComputeCpp(float* input1, float* input2, float* output, int size)
{
	float* pSource1 = input1;
	float* pSource2 = input2;
	float* pDest = output;
	for (int i = 0; i < size; i++)
	{
		*pDest = static_cast<float>(sqrt((*pSource1)*(*pSource1) + (*pSource2)*(*pSource2))) + 0.5f;
		pDest++;
		pSource1++;
		pSource2++;
	}
}

/**
 * 2. 使用Visual C++.NET的 SSE指令函数的代码
 */
void ComputeSSE(float* input1, float* input2, float* output, int size)
{
    // vector分配的内存，对齐方式未知。未指定对齐方式时，请勿直接强转换。
	__m128 *pSrc1 = (__m128*)input1;
	__m128 *pSrc2 = (__m128*)input2;
	__m128 *pDest = (__m128*)output;

	__m128 m1, m2, m3, m4;

	__m128 m5 = _mm_set_ps1(0.5f);
	auto length = size / 4;
	for (int i = 0; i < length; i++)
	{
		m1 = _mm_mul_ps(*pSrc1, *pSrc1);
		m2 = _mm_mul_ps(*pSrc2, *pSrc2);
		m3 = _mm_add_ps(m1, m2);
		m4 = _mm_sqrt_ps(m3);
		*pDest = _mm_add_ps(m4, m5);

		pDest++;
		pSrc1++;
		pSrc2++;
	}
}

/**
 * 3. 包含SSE汇编指令的代码
 */
void ComputeAssembly(float* input1, float* input2, float* output, int size)
{
	int len = size / 4;
	float f = 0.5f;


	_asm
	{
		movss	xmm2, f
		shufps  xmm2, xmm2, 0

		mov		esi, input1
		mov		edx, input2

		mov		edi, output
		mov		ecx, len
	start_loop:

		movaps	xmm0, [esi]
		mulps	xmm0, xmm0

		movaps	xmm1, [edx]
		mulps	xmm1, xmm1

		addps	xmm0, xmm1
		sqrtps	xmm0, xmm0

		addps	xmm0, xmm2

		movaps	[edi],xmm0

		add		esi, 16
		add		edx, 16
		add		edi, 16
		dec		ecx
		jnz		start_loop
	}
}

int main(int argc, char* argv[])
{
	std::default_random_engine e;
	std::normal_distribution<float> n(4, 1.5);
	const int size = 300000;
	std::vector<float> array1(size);
	for (int i = 0; i < size; i++)
	{
		array1[i] = n(e);
	}
	std::vector<float> array2(array1);

	std::vector<float> array3(size);
	std::vector<float> array4(size);
	std::vector<float> array5(size);

	auto start = std::chrono::high_resolution_clock::now();
	ComputeCpp(array1.data(), array2.data(), array3.data(), size);
	std::chrono::duration<float, std::milli> duration = std::chrono::high_resolution_clock::now() - start;
	std::cout << "cpp version:" << duration.count() << std::endl;

	for(int i = 0; i < 10; i++)
	{
		std::cout << array3[i]<< std::endl;
	}


	start = std::chrono::high_resolution_clock::now();
	ComputeSSE(array1.data(), array2.data(), array4.data(), size);
	duration = std::chrono::high_resolution_clock::now() - start;
	std::cout << "sse version:" << duration.count() << std::endl;

	for (int i = 0; i < 10; i++)
	{
		std::cout << array4[i] << std::endl;
	}

	start = std::chrono::high_resolution_clock::now();
	ComputeAssembly(array1.data(), array2.data(), array5.data(), size);
	duration = std::chrono::high_resolution_clock::now() - start;
	std::cout << "assembly version:" << duration.count() << std::endl;

	for (int i = 0; i < 10; i++)
	{
		std::cout << array5[i] << std::endl;
	}
	getchar();
}
```

最后，在我的计算机上运行计算测试的结果（ms）：

|纯C++|SSE的C++函数|SSE汇编指令|
|----|----|----|
|1.97319|0.510577|0.511999|

以上的时间结果是在Release优化编译后执行程序得出的。 


#### SSESample 示例项目

SSESample项目是一个基于对话框的应用程序，其中它用下面的浮点数数组进行计算：

fResult[i] = sqrt(fSource[i]*2.8)

其中i = 0, 1, 2 ... ARRAY_SIZE-1

这个程序同时计算了数组中的最大值和最小值。ARRAY_SIZE被定义为100000，数组中的计算结果在列表框中显示出来。其中在我的机子上用下面三种方法计算所需的时间是：

|纯C++|SSE的C++函数|SSE汇编指令|
|----|----|----|
|3.10101|0.482133|0.330239|

大家看到，使用SSE汇编指令计算的结果会好一些，因为使用了效率增强了的SSX寄存器组。但是在通常情况下，使用SSE的C++ 函数计算会比汇编代码计算的效率更高一些，因为C++编译器的优化后的代码有很高的运算效率，若要使汇编代码比优化后的代码运算效率更高，这通常是很难做 到的。
代码如下：

```c++
#include <iostream>
#include <bitset>
#include <chrono>
#include <vector>
#include <random>
#include <emmintrin.h>

/**
 * 1. 纯C++代码
 */
std::vector<float> ComputeCpp(float* input, float* output, int size)
{
	float* pSource1 = input;
	float* pDest = output;
	float max = std::numeric_limits<float>::min();
	float min = std::numeric_limits<float>::max();
	for (int i = 0; i < size; i++)
	{
		*pDest = static_cast<float>(sqrt((*pSource1)*0.85f));
		if (*pDest > max)
		{
			max = *pDest;
		}
		if (*pDest < min)
		{
			min = *pDest;
		}
		pDest++;
		pSource1++;
	}

	return { max, min };
}

/**
 * 2. 使用Visual C++.NET的 SSE指令函数的代码
 */
std::vector<float> ComputeSSE(float* input, float* output, int size)
{
    // vector分配的内存，对齐方式未知。未指定对齐方式时，请勿直接强转换。
	__m128 *pSrc1 = (__m128*)input;
	__m128 *pDest = (__m128*)output;

	__m128 m8_5 = _mm_set_ps1(0.85f);
	__m128 mmax = _mm_set_ps1(FLT_MIN);
	__m128 mmin = _mm_set_ps1(FLT_MAX);

	__m128 m1;

	auto len = size / 4;

	for (int i = 0; i < len; i ++)
	{
		m1 = _mm_mul_ps(*pSrc1, m8_5);
		*pDest = _mm_sqrt_ps(m1);
		mmax = _mm_max_ps(*pDest, mmax);
		mmin = _mm_min_ps(*pDest, mmin);
		pDest++;
		pSrc1++;
	}

	float max = std::max(mmax.m128_f32[0], std::max(mmax.m128_f32[1], std::max(mmax.m128_f32[2], mmax.m128_f32[3])));
	float min = std::min(mmin.m128_f32[0], std::min(mmin.m128_f32[1], std::min(mmin.m128_f32[2], mmin.m128_f32[3])));
	return { max, min };
}

/**
 * 3. 包含SSE汇编指令的代码
 */
std::vector<float> ComputeAssembly(float* input1, float* output, int size)
{
	int len = size / 4;

	__m128 m8_5 = _mm_set_ps1(0.85f);
	__m128 mmax = _mm_set_ps1(FLT_MIN);
	__m128 mmin = _mm_set_ps1(FLT_MAX);

	__asm
	{
		movaps	xmm2, m8_5

		movaps	xmm3, mmax
		movaps	xmm4, mmin

		mov		esi, input1
		mov		edi, output
		mov		ecx, len
	start_loop:

		movaps	xmm1, [esi]
		mulps	xmm1, xmm2
		sqrtps	xmm1, xmm1
		movaps	[edi],xmm1

		maxps	xmm3, xmm1
		minps	xmm4, xmm1

		add		esi, 16
		add		edi, 16
		dec		ecx
		jnz		start_loop

		movaps	mmax, xmm3
		movaps	mmin, xmm4
	}

	float max = std::max(mmax.m128_f32[0], std::max(mmax.m128_f32[1], std::max(mmax.m128_f32[2], mmax.m128_f32[3])));
	float min = std::min(mmin.m128_f32[0], std::min(mmin.m128_f32[1], std::min(mmin.m128_f32[2], mmin.m128_f32[3])));
	return { max, min };
}

int main(int argc, char* argv[])
{
	std::default_random_engine e;
	std::uniform_real_distribution<float> n(0, 4);
	const int size = 300000;
	std::vector<float> limits(2);
	std::vector<float> array1(size);
	for (int i = 0; i < size; i++)
	{
		array1[i] = n(e);
	}

	std::vector<float> array3(size);
	std::vector<float> array4(size);
	std::vector<float> array5(size);

	auto start = std::chrono::high_resolution_clock::now();
	limits = ComputeCpp(array1.data(), array3.data(), size);
	std::chrono::duration<float, std::milli> duration = std::chrono::high_resolution_clock::now() - start;
	std::cout << "cpp version:" << duration.count() << std::endl;
	std::cout << "max:" << limits[0] << std::endl; 
	std::cout << "min:" << limits[1] << std::endl; 

	for(int i = 0; i < 10; i++)
	{
		std::cout << array3[i]<< std::endl;
	}

	start = std::chrono::high_resolution_clock::now();
	limits = ComputeSSE(array1.data(),array4.data(), size);
	duration = std::chrono::high_resolution_clock::now() - start;
	std::cout << "sse version:" << duration.count() << std::endl;
	std::cout << "max:" << limits[0] << std::endl; 
	std::cout << "min:" << limits[1] << std::endl; 

	for (int i = 0; i < 10; i++)
	{
		std::cout << array4[i] << std::endl;
	}

	start = std::chrono::high_resolution_clock::now();
	limits = ComputeAssembly(array1.data(), array5.data(), size);
	duration = std::chrono::high_resolution_clock::now() - start;
	std::cout << "assembly version:" << duration.count() << std::endl;
	std::cout << "max:" << limits[0] << std::endl; 
	std::cout << "min:" << limits[1] << std::endl; 

	for (int i = 0; i < 10; i++)
	{
		std::cout << array5[i] << std::endl;
	}
	getchar();
}

```
## 常见问题
1. SSE有哪些指令？
    - 浮点指令
        - 记忆体到暂存器/暂存器到记忆体/暂存器之间的资料搬移
        纯量(scalar)：MOVSS
        包裹式(packed)：MOVAPS,MOVUPS,MOVLPS,MOVHPS,MOVLHPS,MOVHLPS
        - 数学运算
        纯量：ADDSS,SUBSS,MULSS,DIVSS,RCPSS,SQRTSS,MAXSS,MINSS,RSQRTSS
        包裹式：ADDPS,SUBPS,MULPS,DIVPS,RCPPS,SQRTPS,MAXPS,MINPS,RSQRTPS
        - 比较
        纯量：CMPSS,COMISS,UCOMISS
        包裹式：CMPPS
        - 资料拆包(unpack)与随机搬移(shuffle)
        包裹式：SHUFPS,UNPCKHPS,UNPCKLPS
        - 资料形态转换
        纯量：CVTSI2SS,CVTSS2SI,CVTTSS2SI
        包裹式：CVTPI2PS,CVTPS2PI,CVTTPS2PI
        - 逐位逻辑运算
        包裹式：ANDPS,ORPS,XORPS,ANDNPS

    - 整数指令
        - 数学运算
        PMULHUW,PSADBW,PAVGB,PAVGW,PMAXUB,PMINUB,PMAXSW,PMINSW
        - 资料搬移
        PEXTRW,PINSRW
        - 其它
        PMOVMSKB,PSHUFW

    - 其它指令
        - MXCSR管理
        LDMXCSR,STMXCSR
        - 快取与记忆体管理(SSE除了运算的指令外，还支持了cache控制指令)
        MOVNTQ,MOVNTPS,MASKMOVQ,PREFETCH0,PREFETCH0,PREFETCH1,PREFECTCH2,PREFETCHNTA,SFENCE
        prefetch指令的主要目的，是提前让CPU载入稍后运算所需要的数据。通常是在对目前的资料进行与运算之前，告诉CPU载入下一批数据。这样就可以让目前的运算和载入下一批数据的动作可以同时进行。不同prefetch指令则是告诉CPU将数据载入不同层次的cache。prefetch指令不会产生任何exception。

    除了prefetch之外，另一個指令是movntps，它的intrinsics是 _mm_stream_ps。這個指令的用途，是要求 CPU 在写入数据的時候，不要把数据写到 cache 中，而是直接將数据写到主记忆体中。实际上它以 write combining 的方式写入的。为什麼要这样做呢？這是因为，很多时候计算的結果并不是立刻需要用到的，通常是很久以后才会用到。所以，这些数据如果被放在 cache 中，完全是浪费空间。而且，更糟的是，它们可能会把 cache 中有用的数据挤掉，而使得这些数据常常需要重新从主记忆体中载入。因此，如果让这些数据不要被放在 cache 中，就可以避免这种問題。
2. SSE Intrinsic 函数有哪些？ (引自 参考文献3)

    - SIMD相关头文件包括：
    
    ```c++
    //#include <ivec.h>//MMX
    //#include <fvec.h>//SSE(also include ivec.h)
    //#include <dvec.h>//SSE2(also include fvec.h)
     
     
    #include <mmintrin.h> //MMX
    #include <xmmintrin.h> //SSE(include mmintrin.h)
    #include <emmintrin.h> //SSE2(include xmmintrin.h)
    #include <pmmintrin.h> //SSE3(include emmintrin.h)
    #include <tmmintrin.h>//SSSE3(include pmmintrin.h)
    #include <smmintrin.h>//SSE4.1(include tmmintrin.h)
    #include <nmmintrin.h>//SSE4.2(include smmintrin.h)
    #include <wmmintrin.h>//AES(include nmmintrin.h)
    #include <immintrin.h>//AVX(include wmmintrin.h)
    #include <intrin.h>//(include immintrin.h)
    ```
    - mmintrin.h为MMX头文件，其中__m64的定义为：

    ```c++
    typedef union __declspec(intrin_type) _CRT_ALIGN(8) __m64
    {
        unsigned __int64    m64_u64;
        float               m64_f32[2];
        __int8              m64_i8[8];
        __int16             m64_i16[4];
        __int32             m64_i32[2];    
        __int64             m64_i64;
        unsigned __int8     m64_u8[8];
        unsigned __int16    m64_u16[4];
        unsigned __int32    m64_u32[2];
    } __m64;
    ```
    - xmmintrin.h为SSE头文件，此头文件里包含MMX头文件，其中__m128的定义为：

    ```c++
    typedef union __declspec(intrin_type) _CRT_ALIGN(16) __m128 {
        float               m128_f32[4];
        unsigned __int64    m128_u64[2];
        __int8              m128_i8[16];
        __int16             m128_i16[8];
        __int32             m128_i32[4];
        __int64             m128_i64[2];
        unsigned __int8     m128_u8[16];
        unsigned __int16    m128_u16[8];
        unsigned __int32    m128_u32[4];
    } __m128;
    ```
    - xmmintrin.h文件中各函数的介绍：

    ```c++
    /*----------Floating Point Intrinsics Using Streaming SIMD Extensions------------*/
	//Arithmetic Operations(Floating Point ):add、sub、mul、div、sqrt、rcp、min、max
	//---------------------说明：_ps结尾的指令表示对4个单精度浮点数同时进行运算，
	//_ss结尾的指令表示仅对4个单精度浮点数最低位的浮点数进行运算---------------------
	//返回一个__m128的寄存器，仅将寄存器_A和寄存器_B最低对应位置的32bit单精度浮点数相加，
	//其余位置取寄存器_A中的数据,例如_A=(_A0,_A1,_A2,_A3), _B=(_B0,_B1,_B2,_B3),
	//则返回寄存器为r=(_A0+_B0, _A1, _A2, _A3)
	extern __m128 _mm_add_ss(__m128 _A, __m128 _B);
	//返回一个__m128的寄存器，将寄存器_A和_B的对应位置的32bit单精度浮点数相加，
	//例如_A=(_A0,_A1,_A2,_A3), _B=(_B0,_B1,_B2,_B3),
	//则返回寄存器r0=_A0+_B0, r1=_A1+_B1, r2=_A2+_B2, r3=_A3+_B3
	extern __m128 _mm_add_ps(__m128 _A, __m128 _B);
	//返回一个__m128的寄存器，仅将寄存器_A和寄存器_B最低对应位置的32bit单精度浮点数相减，
	//其余位置取寄存器_A中的数据,例如_A=(_A0,_A1,_A2,_A3), _B=(_B0,_B1,_B2,_B3),
	//则返回寄存器为r=(_A0-_B0, _A1, _A2, _A3)
	extern __m128 _mm_sub_ss(__m128 _A, __m128 _B);
	//返回一个__m128的寄存器，将寄存器_A和_B的对应位置的32bit单精度浮点数相减，
	//例如_A=(_A0,_A1,_A2,_A3), _B=(_B0,_B1,_B2,_B3),
	//则返回寄存器r0=_A0-_B0, r1=_A1-_B1, r2=_A2-_B2, r3=_A3-_B3
	extern __m128 _mm_sub_ps(__m128 _A, __m128 _B);
	//返回一个__m128的寄存器，仅将寄存器_A和寄存器_B最低对应位置的32bit单精度浮点数相乘，
	//其余位置取寄存器_A中的数据,例如_A=(_A0,_A1,_A2,_A3), _B=(_B0,_B1,_B2,_B3),
	//则返回寄存器为r=(_A0*_B0, _A1, _A2, _A3)
	extern __m128 _mm_mul_ss(__m128 _A, __m128 _B);
	//返回一个__m128的寄存器，将寄存器_A和_B的对应位置的32bit单精度浮点数相乘，
	//例如_A=(_A0,_A1,_A2,_A3), _B=(_B0,_B1,_B2,_B3),
	//则返回寄存器r0=_A0*_B0, r1=_A1*_B1, r2=_A2*_B2, r3=_A3*_B3
	extern __m128 _mm_mul_ps(__m128 _A, __m128 _B);
	//返回一个__m128的寄存器，仅将寄存器_A和寄存器_B最低对应位置的32bit单精度浮点数相除，
	//其余位置取寄存器_A中的数据,例如_A=(_A0,_A1,_A2,_A3), _B=(_B0,_B1,_B2,_B3),
	//则返回寄存器为r=(_A0/_B0, _A1, _A2, _A3)
	extern __m128 _mm_div_ss(__m128 _A, __m128 _B);
	//返回一个__m128的寄存器，将寄存器_A和_B的对应位置的32bit单精度浮点数相除，
	//例如_A=(_A0,_A1,_A2,_A3), _B=(_B0,_B1,_B2,_B3),
	//则返回寄存器r0=_A0/_B0, r1=_A1/_B1, r2=_A2/_B2, r3=_A3/_B3
	extern __m128 _mm_div_ps(__m128 _A, __m128 _B);
	//返回一个__m128的寄存器，仅将寄存器_A最低对应位置的32bit单精度浮点数开平方，
	//其余位置取寄存器_A中的数据,例如_A=(_A0,_A1,_A2,_A3)
	//则返回寄存器为r=(sqrt(_A0), _A1, _A2, _A3)
	extern __m128 _mm_sqrt_ss(__m128 _A);
	//返回一个__m128的寄存器，将寄存器_A中4个32bit单精度浮点数开平方，
	//例如_A=(_A0,_A1,_A2,_A3)，则返回寄存器为
	//r=(sqrt(_A0), sqrt(_A1), sqrt(_A2), sqrt(_A3))
	extern __m128 _mm_sqrt_ps(__m128 _A);
	//返回一个__m128的寄存器，仅将寄存器_A最低对应位置的32bit单精度浮点数取倒数，
	//其余位置取寄存器_A中的数据,例如_A=(_A0,_A1,_A2,_A3)
	//则返回寄存器为r=(recip(_A0), _A1, _A2, _A3)
	extern __m128 _mm_rcp_ss(__m128 _A);
	//返回一个__m128的寄存器，将寄存器_A中4个32bit单精度浮点数取倒数，
	//例如_A=(_A0,_A1,_A2,_A3)，则返回寄存器为
	//r=(recip(_A0), recip(_A1), recip(_A2), recip(_A3))
	extern __m128 _mm_rcp_ps(__m128 _A);
	//返回一个__m128的寄存器，仅将寄存器_A最低对应位置的32bit单精度浮点数取平方根的倒数，
	//其余位置取寄存器_A中的数据,例如_A=(_A0,_A1,_A2,_A3)
	//则返回寄存器为r=(recip(sqrt(_A0)), _A1, _A2, _A3)
	extern __m128 _mm_rsqrt_ss(__m128 _A);
	//返回一个__m128的寄存器，将寄存器_A中4个32bit单精度浮点数取平方根的倒数，
	//例如_A=(_A0,_A1,_A2,_A3)，则返回寄存器为
	//r=(recip(sqrt(_A0)), recip(sqrt(_A1)), recip(sqrt(_A2)), recip(sqrt(_A3)))
	extern __m128 _mm_rsqrt_ps(__m128 _A);
	//返回一个__m128的寄存器，仅将寄存器_A和寄存器_B最低对应位置的32bit单精度浮点数取最小值，
	//其余位置取寄存器_A中的数据,例如_A=(_A0,_A1,_A2,_A3), _B=(_B0,_B1,_B2,_B3),
	//则返回寄存器为r=(min(_A0,_B0), _A1, _A2, _A3)
	extern __m128 _mm_min_ss(__m128 _A, __m128 _B);
	//返回一个__m128的寄存器，将寄存器_A和_B的对应位置的32bit单精度浮点数取最小值，
	//例如_A=(_A0,_A1,_A2,_A3), _B=(_B0,_B1,_B2,_B3),
	//则返回寄存器r0=min(_A0,_B0), r1=min(_A1,_B1), r2=min(_A2,_B2), r3=min(_A3,_B3)
	extern __m128 _mm_min_ps(__m128 _A, __m128 _B);
	//返回一个__m128的寄存器，仅将寄存器_A和寄存器_B最低对应位置的32bit单精度浮点数取最大值，
	//其余位置取寄存器_A中的数据,例如_A=(_A0,_A1,_A2,_A3), _B=(_B0,_B1,_B2,_B3),
	//则返回寄存器为r=(max(_A0,_B0), _A1, _A2, _A3)
	extern __m128 _mm_max_ss(__m128 _A, __m128 _B);
	//返回一个__m128的寄存器，将寄存器_A和_B的对应位置的32bit单精度浮点数取最大值，
	//例如_A=(_A0,_A1,_A2,_A3), _B=(_B0,_B1,_B2,_B3),
	//则返回寄存器r0=max(_A0,_B0), r1=max(_A1,_B1), r2=max(_A2,_B2), r3=max(_A3,_B3)
	extern __m128 _mm_max_ps(__m128 _A, __m128 _B);
 
	//Logical Operations(SSE)：and、andnot、or、xor
	//返回一个__m128的寄存器，将寄存器_A和_B的对应位置的32bit单精度浮点数分别进行按位与运算，
	//例如_A=(_A0,_A1,_A2,_A3), _B=(_B0,_B1,_B2,_B3),
	//则返回寄存器r0=_A0 & _B0, r1=_A1 & _B1, r2=_A2 & _B2, r3=_A3 & _B3
	extern __m128 _mm_and_ps(__m128 _A, __m128 _B);
	//返回一个__m128的寄存器，将寄存器_A对应位置的32bit单精度浮点数的非和寄存器_B对应位置的32bit
	//单精度浮点数分别进行按位与运算，例如_A=(_A0,_A1,_A2,_A3), _B=(_B0,_B1,_B2,_B3),
	//则返回寄存器r0=~_A0 & _B0, r1=~_A1 & _B1, r2=~_A2 & _B2, r3=~_A3 & _B3
	extern __m128 _mm_andnot_ps(__m128 _A, __m128 _B);
	//返回一个__m128的寄存器，将寄存器_A和_B的对应位置的32bit单精度浮点数分别进行按位或运算，
	//例如_A=(_A0,_A1,_A2,_A3), _B=(_B0,_B1,_B2,_B3),
	//则返回寄存器r0=_A0 | _B0, r1=_A1 | _B1, r2=_A2 | _B2, r3=_A3 | _B3
	extern __m128 _mm_or_ps(__m128 _A, __m128 _B);
	//返回一个__m128的寄存器，将寄存器_A和_B的对应位置的32bit单精度浮点数分别进行按位异或运算，
	//例如_A=(_A0,_A1,_A2,_A3), _B=(_B0,_B1,_B2,_B3),
	//则返回寄存器r0=_A0 ^ _B0, r1=_A1 ^ _B1, r2=_A2 ^ _B2, r3=_A3 ^ _B3
	extern __m128 _mm_xor_ps(__m128 _A, __m128 _B);
 
	//Comparison Intrinsics(SSE):==、<、<=、>、>=、!=、不小于、不小于等于、不大于、不大于等于
	//返回一个__m128的寄存器，Compares for equality,
	//r0=(_A0 == _B0) ? 0xffffffff : 0x0, r1=_A1, r2=_A2, r3=_A3
	extern __m128 _mm_cmpeq_ss(__m128 _A, __m128 _B);
	//返回一个__m128的寄存器，Compares for equality,
	//r0=(_A0 == _B0) ? 0xffffffff : 0x0, r1=(_A1 == _B1) ? 0xffffffff : 0x0, 
	//r2=(_A2 == _B2) ? 0xffffffff : 0x0, r3=(_A3 == _B3) ? 0xffffffff : 0x0
	extern __m128 _mm_cmpeq_ps(__m128 _A, __m128 _B);
	//返回一个__m128的寄存器，Compares for less than,
	//r0=(_A0 < _B0) ? 0xffffffff : 0x0, r1=_A1, r2=_A2, r3=_A3
	extern __m128 _mm_cmplt_ss(__m128 _A, __m128 _B);
	//返回一个__m128的寄存器，Compares for less than,
	//r0=(_A0 < _B0) ? 0xffffffff : 0x0, r1=(_A1 < _B1) ? 0xffffffff : 0x0, 
	//r2=(_A2 < _B2) ? 0xffffffff : 0x0, r3=(_A3 < _B3) ? 0xffffffff : 0x0
	extern __m128 _mm_cmplt_ps(__m128 _A, __m128 _B);
	//返回一个__m128的寄存器，Compares for less than or equal,
	//r0=(_A0 <= _B0) ? 0xffffffff : 0x0, r1=_A1, r2=_A2, r3=_A3
	extern __m128 _mm_cmple_ss(__m128 _A, __m128 _B);
	//返回一个__m128的寄存器，Compares for less than or equal,
	//r0=(_A0 <= _B0) ? 0xffffffff : 0x0, r1=(_A1 <= _B1) ? 0xffffffff : 0x0, 
	//r2=(_A2 <= _B2) ? 0xffffffff : 0x0, r3=(_A3 <= _B3) ? 0xffffffff : 0x0
	extern __m128 _mm_cmple_ps(__m128 _A, __m128 _B);
	//返回一个__m128的寄存器，Compares for greater than,
	//r0=(_A0 > _B0) ? 0xffffffff : 0x0, r1=_A1, r2=_A2, r3=_A3
	extern __m128 _mm_cmpgt_ss(__m128 _A, __m128 _B);
	//返回一个__m128的寄存器，Compares for greater than,
	//r0=(_A0 > _B0) ? 0xffffffff : 0x0, r1=(_A1 > _B1) ? 0xffffffff : 0x0, 
	//r2=(_A2 > _B2) ? 0xffffffff : 0x0, r3=(_A3 > _B3) ? 0xffffffff : 0x0
	extern __m128 _mm_cmpgt_ps(__m128 _A, __m128 _B);
	//返回一个__m128的寄存器，Compares for greater than or equal,
	//r0=(_A0 >= _B0) ? 0xffffffff : 0x0, r1=_A1, r2=_A2, r3=_A3
	extern __m128 _mm_cmpge_ss(__m128 _A, __m128 _B);
	//返回一个__m128的寄存器，Compares for greater than or equal,
	//r0=(_A0 >= _B0) ? 0xffffffff : 0x0, r1=(_A1 >= _B1) ? 0xffffffff : 0x0, 
	//r2=(_A2 >= _B2) ? 0xffffffff : 0x0, r3=(_A3 >= _B3) ? 0xffffffff : 0x0
	extern __m128 _mm_cmpge_ps(__m128 _A, __m128 _B);
	//返回一个__m128的寄存器，Compares for inequality,
	//r0=(_A0 != _B0) ? 0xffffffff : 0x0, r1=_A1, r2=_A2, r3=_A3
	extern __m128 _mm_cmpneq_ss(__m128 _A, __m128 _B);
	//返回一个__m128的寄存器，Compares for inequality,
	//r0=(_A0 != _B0) ? 0xffffffff : 0x0, r1=(_A1 != _B1) ? 0xffffffff : 0x0, 
	//r2=(_A2 != _B2) ? 0xffffffff : 0x0, r3=(_A3 != _B3) ? 0xffffffff : 0x0
	extern __m128 _mm_cmpneq_ps(__m128 _A, __m128 _B);
	//返回一个__m128的寄存器，Compares for not less than,
	//r0= !(_A0 < _B0) ? 0xffffffff : 0x0, r1=_A1, r2=_A2, r3=_A3
	extern __m128 _mm_cmpnlt_ss(__m128 _A, __m128 _B);
	//返回一个__m128的寄存器，Compares for not less than,
	//r0=!(_A0 < _B0) ? 0xffffffff : 0x0, r1=!(_A1 < _B1) ? 0xffffffff : 0x0, 
	//r2=!(_A2 < _B2) ? 0xffffffff : 0x0, r3=!(_A3 < _B3) ? 0xffffffff : 0x0
	extern __m128 _mm_cmpnlt_ps(__m128 _A, __m128 _B);
	//返回一个__m128的寄存器，Compares for not less than or equal
	//r0= !(_A0 <= _B0) ? 0xffffffff : 0x0, r1=_A1, r2=_A2, r3=_A3
	extern __m128 _mm_cmpnle_ss(__m128 _A, __m128 _B);
	//返回一个__m128的寄存器，Compares for not less than or equal
	//r0=!(_A0 <= _B0) ? 0xffffffff : 0x0, r1=!(_A1 <= _B1) ? 0xffffffff : 0x0, 
	//r2=!(_A2 <= _B2) ? 0xffffffff : 0x0, r3=!(_A3 <= _B3) ? 0xffffffff : 0x0
	extern __m128 _mm_cmpnle_ps(__m128 _A, __m128 _B);
	//返回一个__m128的寄存器，Compares for not greater than,
	//r0=!(_A0 > _B0) ? 0xffffffff : 0x0, r1=_A1, r2=_A2, r3=_A3
	extern __m128 _mm_cmpngt_ss(__m128 _A, __m128 _B);
	//返回一个__m128的寄存器，Compares for not greater than,
	//r0=!(_A0 > _B0) ? 0xffffffff : 0x0, r1=!(_A1 > _B1) ? 0xffffffff : 0x0, 
	//r2=!(_A2 > _B2) ? 0xffffffff : 0x0, r3=!(_A3 > _B3) ? 0xffffffff : 0x0
	extern __m128 _mm_cmpngt_ps(__m128 _A, __m128 _B);
	//返回一个__m128的寄存器，Compares for not greater than or equal,
	//r0=!(_A0 >= _B0) ? 0xffffffff : 0x0, r1=_A1, r2=_A2, r3=_A3
	extern __m128 _mm_cmpnge_ss(__m128 _A, __m128 _B);
	//返回一个__m128的寄存器，Compares for not greater than or equal,
	//r0=!(_A0 >= _B0) ? 0xffffffff : 0x0, r1=!(_A1 >= _B1) ? 0xffffffff : 0x0, 
	//r2=!(_A2 >= _B2) ? 0xffffffff : 0x0, r3=!(_A3 >= _B3) ? 0xffffffff : 0x0
	extern __m128 _mm_cmpnge_ps(__m128 _A, __m128 _B);
	//返回一个__m128的寄存器，Compares for ordered,
	//r0=(_A0 ord? _B0) ? 0xffffffff : 0x0, r1=_A1, r2=_A2, r3=_A3
	extern __m128 _mm_cmpord_ss(__m128 _A, __m128 _B);
	//返回一个__m128的寄存器，Compares for ordered,
	//r0=(_A0 ord? _B0) ? 0xffffffff : 0x0, r1=(_A1 ord? _B1) ? 0xffffffff : 0x0, 
	//r2=(_A2 ord? _B2) ? 0xffffffff : 0x0, r3=(_A3 ord? _B3) ? 0xffffffff : 0x0
	extern __m128 _mm_cmpord_ps(__m128 _A, __m128 _B);
	//返回一个__m128的寄存器，Compares for unordered,
	//r0=(_A0 unord? _B0) ? 0xffffffff : 0x0, r1=_A1, r2=_A2, r3=_A3	
	extern __m128 _mm_cmpunord_ss(__m128 _A, __m128 _B);
	//返回一个__m128的寄存器，Compares for unordered,
	//r0=(_A0 unord? _B0) ? 0xffffffff : 0x0, r1=(_A1 unord? _B1) ? 0xffffffff : 0x0, 
	//r2=(_A2 unord? _B2) ? 0xffffffff : 0x0, r3=(_A3 unord? _B3) ? 0xffffffff : 0x0
	extern __m128 _mm_cmpunord_ps(__m128 _A, __m128 _B);
	//返回一个0或1的整数，Compares the lower single-precision, floating-point value of
	//a and b for a equal to b,If a and b are equal, 1 is returned. Otherwise,
	//0 is returned. If a or b is a NaN, 1 is returned
	//r=(_A0 == _B0) ? 0x1 : 0x0
	extern int _mm_comieq_ss(__m128 _A, __m128 _B);
	//返回一个0或1的整数，If a is less than b, 1 is returned. Otherwise, 
	//0 is returned. If a or b is a NaN, 1 is returned,
	//r=(_A0 < _B0) ? 0x1 : 0x0
	extern int _mm_comilt_ss(__m128 _A, __m128 _B);
	//返回一个0或1的整数，If a is less than or equal to b, 1 is returned. 
	//Otherwise, 0 is returned. If a or b is a NaN, 1 is returned,
	//r=(_A0 <= _B0) ? 0x1 : 0x0
	extern int _mm_comile_ss(__m128 _A, __m128 _B);
	//返回一个0或1的整数，If a is greater than b, 1 is returned.
	//Otherwise, 0 is returned. If a or b is a NaN, 1 is returned,
	//r=(_A0 > _B0) ? 0x1 : 0x0
	extern int _mm_comigt_ss(__m128 _A, __m128 _B);
	//返回一个0或1的整数，If a is greater than or equal to b, 1 is returned. 
	//Otherwise, 0 is returned. If a or b is a NaN, 1 is returned,
	//r=(_A0 >= _B0) ? 0x1 : 0x0
	extern int _mm_comige_ss(__m128 _A, __m128 _B);
	//返回一个0或1的整数，If a and b are not equal, 1 is returned. 
	//Otherwise, 0 is returned. If a or b is a NaN, 1 is returned,
	//r=(_A0 != _B0) ? 0x1 : 0x0
	extern int _mm_comineq_ss(__m128 _A, __m128 _B);
	//返回一个0或1的整数，If a and b are equal, 1 is returned. 
	//Otherwise, 0 is returned. If a or b is a NaN, 1 is returned,
	//r=(_A0 == _B0) ? 0x1 : 0x0	
	extern int _mm_ucomieq_ss(__m128 _A, __m128 _B);
	//返回一个0或1的整数，If a is less than b , 1 is returned. 
	//Otherwise, 0 is returned. If a or b is a NaN, 1 is returned,
	//r=(_A0 < _B0) ? 0x1 : 0x0
	extern int _mm_ucomilt_ss(__m128 _A, __m128 _B);
	//返回一个0或1的整数，If a is less than or equal to b, 1 is returned. 
	//Otherwise, 0 is returned. If a or b is a NaN, 1 is returned,
	//r=(_A0 <= _B0) ? 0x1 : 0x0
	extern int _mm_ucomile_ss(__m128 _A, __m128 _B);
	//返回一个0或1的整数，If a is greater than b, 1 is returned. 
	//Otherwise, 0 is returned. If a or b is a NaN, 1 is returned,
	//r=(_A0 > _B0) ? 0x1 : 0x0
	extern int _mm_ucomigt_ss(__m128 _A, __m128 _B);
	//返回一个0或1的整数，If a is greater than or equal to b, 1 is returned.
	//Otherwise, 0 is returned,r=(_A0 >= _B0) ? 0x1 : 0x0
	extern int _mm_ucomige_ss(__m128 _A, __m128 _B);
	//返回一个0或1的整数，If a and b are not equal, 1 is returned. 
	//Otherwise, 0 is returned. If a or b is a NaN, 1 is returned,
	//r=(_A0 != _B0) ? 0x1 : 0x0
	extern int _mm_ucomineq_ss(__m128 _A, __m128 _B);
 
	//Conversion Operations(SSE)
	//返回一个32bit的整数，Converts the lower single-precision, floating-point value
	//of a to a 32-bit integer according to the current rounding mode, r=(int)_A0
	extern int _mm_cvt_ss2si(__m128 _A);//=_mm_cvtss_si32
	//返回一个__m64寄存器，Converts the two lower single-precision, floating-point 
	//values of a to two 32-bit integers according to the current rounding mode, 
	//returning the integers in packed form, r0=(int)_A0, r1=(int)_A1
	extern __m64 _mm_cvt_ps2pi(__m128 _A);//=_mm_cvtps_pi32
	//返回一个32bit的整数，Converts the lower single-precision, floating-point value
	//of a to a 32-bit integer with truncation, r=(int)_A0
	extern int _mm_cvtt_ss2si(__m128 _A);//=_mm_cvttss_si32
	//返回一个__m64寄存器，Converts the two lower single-precision, floating-point 
	//values of a to two 32-bit integer with truncation, returning the integers 
	//in packed form, r0=(int)_A0, r1=(int)_A1
	extern __m64 _mm_cvtt_ps2pi(__m128 _A);//=_mm_cvttps_pi32
	//返回一个__m128的寄存器，Converts the 32-bit integer value b to an single-precision,
	//floating-point value; the upper three single-precision, floating-point values are
	//passed through from a, r0=(float)_B, r1=_A1, r2=_A2, r3=_A3
	extern __m128 _mm_cvt_si2ss(__m128 _A, int _B);//=_mm_cvtsi32_ss 
	//返回一个__m128的寄存器，Converts the two 32-bit integer values in packed form in b
	//to two single-precision, floating-point values; the upper two single-precision, 
	//floating-point values are passed through from a
	//r0=(float)_B0, r1=(float)_B1, r2=_A2, r3=_A3
	extern __m128 _mm_cvt_pi2ps(__m128 _A, __m64 _B);//=_mm_cvtpi32_ps
	//返回一个__m128的寄存器，Converts the four 16-bit signed integer values in a to 
	//four single-precision, floating-point values
	//r0=(float)_A0, r1=(float)_A1, r2=(float)_A2, r3=(float)_A3
	__inline __m128 _mm_cvtpi16_ps(__m64 _A);
	//返回一个__m128的寄存器，Converts the four 16-bit unsigned integer values in a
	//to four single-precision, floating-point values
	//r0=(float)_A0, r1=(float)_A1, r2=(float)_A2, r3=(float)_A3
	__inline __m128 _mm_cvtpu16_ps(__m64 _A);
	//返回一个__m64的寄存器，Converts the four single-precision, floating-point values
	//in a to four signed 16-bit integer values
	//r0=(short)_A0, r1=(short)_A1, r2=(short)_A2, r3=(short)_A3
	__inline __m64 _mm_cvtps_pi16(__m128 _A);
	//返回一个__m128的寄存器，Converts the lower four 8-bit signed integer values in a 
	//to four single-precision, floating-point values
	//r0=(float)_A0, r1=(float)_A1, r2=(float)_A2, r3=(float)_A3
	__inline __m128 _mm_cvtpi8_ps(__m64 _A);
	//返回一个__m128的寄存器，Converts the lower four 8-bit unsigned integer values in a
	//to four single-precision, floating-point values
	//r0=(float)_A0, r1=(float)_A1, r2=(float)_A2, r3=(float)_A3
	__inline __m128 _mm_cvtpu8_ps(__m64 _A);
	//返回一个__m64的寄存器，Converts the four single-precision, floating-point values 
	//in a to the lower four signed 8-bit integer values of the result
	//r0=(char)_A0, r1=(char)_A1, r2=(char)_A2, r3=(char)_A3
	__inline __m64 _mm_cvtps_pi8(__m128 _A);
	//返回一个__m128的寄存器，Converts the two 32-bit signed integer values in a and the
	//two 32-bit signed integer values in b to four single-precision, floating-point values
	//r0=(float)_A0, r1=(float)_A1, r2=(float)_B0, r3=(float)_B1
	__inline __m128 _mm_cvtpi32x2_ps(__m64 _A, __m64 _B);
	//返回一个32bit浮点数，Extracts the lower order floating point value from the parameter
	//r=_A0
	extern float _mm_cvtss_f32(__m128 _A);
 
	//Miscellaneous Instructions That Use Streaming SIMD Extensions:
	//返回一个__m128的寄存器，Selects four specific single-precision, floating-point 
	//values from a and b, based on the mask i
	extern __m128 _mm_shuffle_ps(__m128 _A, __m128 _B, unsigned int _Imm8);
	//返回一个__m128的寄存器，Selects and interleaves the upper two single-precision,
	//floating-point values from a and b
	//r0=_A2, r1=_B2, r2=_A3, r3=_B3
	extern __m128 _mm_unpackhi_ps(__m128 _A, __m128 _B);
	//返回一个__m128的寄存器，Selects and interleaves the lower two single-precision,
	//floating-point values from a and b
	//r0=_A0, r1=_B0, r2=_A1, r3=_B1
	extern __m128 _mm_unpacklo_ps(__m128 _A, __m128 _B);
	//返回一个__m128的寄存器，Sets the upper two single-precision, floating-point 
	//values with 64 bits of data loaded from the address p; the lower two values
	//are passed through from a
	//r0=_A0, r1=_A1, r2=*_P0, r3=*_P1
	extern __m128 _mm_loadh_pi(__m128 _A, __m64 const* _P);
	//返回一个__m128的寄存器，Moves the upper two single-precision, floating-point
	//values of b to the lower two single-precision, floating-point values of the result
	//r3=_A3, r2=_A2, r1=_B3, r0=_B2
	extern __m128 _mm_movehl_ps(__m128 _A, __m128 _B);
	//返回一个__m128的寄存器，Moves the lower two single-precision, floating-point 
	//values of b to the upper two single-precision, floating-point values of the result
	//r3=_B1, r2=_B0, r1=_A1, r0=_A0
	extern __m128 _mm_movelh_ps(__m128 _A, __m128 _B);
	//返回为空，Stores the upper two single-precision, floating-point values of a 
	//to the address p, *_P0=_A2, *_P1=_A3
	extern void _mm_storeh_pi(__m64 *_P, __m128 _A);
	//返回一个__m128的寄存器，Sets the lower two single-precision, floating-point
	//values with 64 bits of data loaded from the address p; the upper two values
	//are passed through from a
	//r0=*_P0, r1=*_P1, r2=_A2, r3=_A3	
	extern __m128 _mm_loadl_pi(__m128 _A, __m64 const* _P);
	//返回为空，Stores the lower two single-precision, floating-point values of a
	//to the address p, *_P0=_A0, *_P1=_A1
	extern void _mm_storel_pi(__m64 *_P, __m128 _A);
	//返回一个整数，Creates a 4-bit mask from the most significant bits of the
	//four single-precision, floating-point values	
	//r=sign(_A3)<<3 | sign(_A2)<<2 | sign(_A1)<<1 | sign(_A0)
	extern int _mm_movemask_ps(__m128 _A);
	//返回一个无符号整数，Returns the contents of the control register
	extern unsigned int _mm_getcsr(void);
	//返回为空，Sets the control register to the value specified
	extern void _mm_setcsr(unsigned int);
 
	//Memory and Initialization Using Streaming SIMD Extensions
	//Load Operations(SSE)
	//返回一个__m128的寄存器，Loads an single-precision, floating-point value into
	//the low word and clears the upper three words
	//r0=*_P, r1=0.0, r2=0.0, r3=0.0
	extern __m128 _mm_load_ss(float const* _P);
	//返回一个__m128的寄存器，Loads a single single-precision, floating-point value,
	//copying it into all four words
	//r0=*_P0, r1=*_P1, r2=*_P2, r3=*_P3
	extern __m128 _mm_load_ps1(float const* _P);//=_mm_load1_ps
	//返回一个__m128的寄存器，Loads four single-precision, floating-point values
	//The address must be 16-byte aligned
	//r0=_P[0], r1=_P[1], r2=_P[2], r3=_P[3]
	extern __m128 _mm_load_ps(float const* _P);
	//返回一个__m128的寄存器，Loads four single-precision, floating-point values 
	//in reverse order, The address must be 16-byte aligned
	//r0=_P[3], r1=_P[2], r2=_P[1], r3=_P[0]
	extern __m128 _mm_loadr_ps(float const* _P);
	//返回一个__m128的寄存器，Loads four single-precision, floating-point values
	//The address does not need to be 16-byte aligned
	//r0=_P[0], r1=_P[1], r2=_P[2], r3=_P[3]
	extern __m128 _mm_loadu_ps(float const* _P);
 
	//Set Operations(SSE)
	//返回一个__m128的寄存器，Sets the low word of an single-precision, 
	//floating-point value to w and clears the upper three words
	//r0=_W, r1=r2=r3=0.0
	extern __m128 _mm_set_ss(float _W);
	//返回一个__m128的寄存器，Sets the four single-precision, floating-point values to w
	//r0=r1=r2=r3=_W
	extern __m128 _mm_set_ps1(float _W);//=_mm_set1_ps
	//返回一个__m128的寄存器，Sets the four single-precision, floating-point values to 
	//the four inputs, r0=_D, r1=_C, r2=_B, r3=_A
	extern __m128 _mm_set_ps(float _A, float _B, float _C, float _D);
	//返回一个__m128的寄存器，Sets the four single-precision, floating-point values to
	//the four inputs in reverse order, r0=_A, r1=_B, r2=_C, r3=_D
	extern __m128 _mm_setr_ps(float _A, float _B, float _C, float _D);
	//返回一个__m128的寄存器，Clears the four single-precision, floating-point values
	//r0=r1=r2=r3=0.0
	extern __m128 _mm_setzero_ps(void);
 
	//Store Operations(SSE)
	//返回为空，Stores the lower single-precision, floating-point value，*_V=_A0
	extern void _mm_store_ss(float *_V, __m128 _A);
	//返回为空，Stores the lower single-precision, floating-point value across four words
	//_V[0]=_A0, _V[1]=_A0, _V[2]=_A0, _V[3]=_A0
	extern void _mm_store_ps1(float *_V, __m128 _A);//=_mm_store1_ps
	//返回为空，Stores four single-precision, floating-point values
	//The address must be 16-byte aligned
	//_V[0]=_A0, _V[1]=_A1, _V[2]=_A2, _V[3]=_A3
	extern void _mm_store_ps(float *_V, __m128 _A);
	//返回为空，Stores four single-precision, floating-point values in reverse order
	//The address must be 16-byte aligned,
	//_V[0]=_A3, _V[1]=_A2, _V[2]=_A1, _V[3]=_A0
	extern void _mm_storer_ps(float *_V, __m128 _A);
	//返回为空，Stores four single-precision, floating-point values,
	//The address does not need to be 16-byte aligned
	//_V[0]=_A0, _V[1]=_A1, _V[2]=_A2, _V[3]=_A3
	extern void _mm_storeu_ps(float *_V, __m128 _A);
	//返回一个__m128的寄存器，Sets the low word to the single-precision, floating-point
	//value of b,The upper 3 single-precision, floating-point values are passed through 
	//from a, r0=_B0, r1=_A1, r2=_A2, r3=_A3		
	extern __m128 _mm_move_ss(__m128 _A, __m128 _B);
 
	//Integer Intrinsics Using Streaming SIMD Extensions
	//返回一个16bit整数，Extracts one of the four words of a，
	//The selector n must be an immediate,
	//r=(_Imm == 0) ? _A0 : ((_Imm==1) ? _A1 : ((_Imm==2) ? _A2 : _A3))
	extern int _m_pextrw(__m64 _A, int _Imm);//=_mm_extract_pi16
	//返回一个__m64的寄存器,Inserts word d into one of four words of a,
	//The selector n must be an immediate
	//r0=(_Imm==0)? _D : _A0, r1=(_Imm==1)? _D : _A1,
	//r2=(_Imm==2)? _D : _A2, r3=(_Imm==3)? _D : _A3
	extern __m64 _m_pinsrw(__m64 _A, int _D, int _Imm);//=_mm_insert_pi16
	//返回一个__m64的寄存器,Computes the element-wise maximum of the words in a and b,
	//r0=max(_A0, _B0), r1=max(_A1, _B1), r2=max(_A2, _B2), r3=max(_A3, _B3)
	extern __m64 _m_pmaxsw(__m64 _A, __m64 _B);//=_mm_max_pi16
	//返回一个__m64的寄存器,Computes the element-wise maximum of the unsigned bytes in
	//a and b, r0=max(_A0, _B0), r1=max(_A1, _B1), ... r7=max(_A7, _B7)
	extern __m64 _m_pmaxub(__m64 _A, __m64 _B);//=_mm_max_pu8
	//返回一个__m64的寄存器,Computes the element-wise minimum of the words in a and b
	//r0=min(_A0, _B0), r1=min(_A1, _B1), r2=min(_A2, _B2), r3=min(_A3, _B3)
	extern __m64 _m_pminsw(__m64 _A, __m64 _B);//=_mm_min_pi16
	//返回一个__m64的寄存器,Computes the element-wise minimum of the unsigned bytes
	//in a and b, r0=min(_A0, _B0), r1=min(_A1, _B1), ... r7=min(_A7, _B7)
	extern __m64 _m_pminub(__m64 _A, __m64 _B);//=_mm_min_pu8
	//返回一个整数，Creates an 8-bit mask from the most significant bits of the
	//bytes in a, r=sign(_A7)<<7 | sign(_A6)<<6 | ... | sign(_A0)
	extern int _m_pmovmskb(__m64 _A);//=_mm_movemask_pi8
	//返回一个__m64的寄存器,Multiplies the unsigned words in a and b, returning the
	//upper 16 bits of the 32-bit intermediate results,
	//r0=hiword(_A0, _B0), r1=hiword(_A1, _B1), r2=hiword(_A2, _B2), r3=hiword(_A3, _B3)
	extern __m64 _m_pmulhuw(__m64 _A, __m64 _B);//=_mm_mulhi_pu16
	//返回为空，Conditionally stores byte elements of d to address p,The high bit of 
	//each byte in the selector _B determines whether the corresponding byte in _A 
	//will be stored, if (sign(_B0)) _P[0]=_A0, if (sign(_B1)) _P[1]=_A1, ...
	//if (sign(_B7)) _P[7]=_A7
	extern void _m_maskmovq(__m64 _A, __m64 _B, char * _P);//=_mm_maskmove_si64
	//返回一个__m64的寄存器,Computes the (rounded) averages of the unsigned bytes 
	//in a and b, t=(unsigned short)_A0 + (unsigned short)_B0, r0=(t>>1) | (t & 0x01),
	//..., t=(unsigned short)_A7 + (unsigned short)_B7, r7=(t>>1) | (t & 0x01)	
	extern __m64 _m_pavgb(__m64 _A, __m64 _B);//=_mm_avg_pu8
	//返回一个__m64的寄存器,Computes the (rounded) averages of the unsigned words
	//in a and b, t=(unsigned short)_A0 + (unsigned short)_B0, r0=(t>>1) | (t & 0x01),
	//..., t=(unsigned short)_A4 + (unsigned short)_B4, r7=(t>>1) | (t & 0x01)
	extern __m64 _m_pavgw(__m64 _A, __m64 _B);//=_mm_avg_pu16
	//返回一个__m64的寄存器,Computes the sum of the absolute differences of the unsigned
	//bytes in a and b, returning the value in the lower word
	//The upper three words are cleared
	//r0=abs(_A0-_B0) + ... + abs(_A7-_B7), r1=r2=r3=0
	extern __m64 _m_psadbw(__m64, __m64);//=_mm_sad_pu8
	//返回一个__m64的寄存器,Returns a combination of the four words of a.
	//The selector _Imm must be an immediate
	//r0=word(_Imm & 0x03) of _A, r1=word((_Imm>>2) & 0x03) of _A, 
	//r2=word((_Imm>>4) & 0x03) of _A, r1=word((_Imm>>6) & 0x03) of _A, 
	extern __m64 _m_pshufw(__m64 _A, int _Imm);//=_mm_shuffle_pi16
 
	//Streaming SIMD Extensions that Support the Cache
	//返回为空，Loads one cache line of data from address p to a location closer
	//to the processor, The value _Sel specifies the type of prefetch operation
	extern void _mm_prefetch(char const*_A, int _Sel);
	//返回为空，Stores the data in a to the address p without polluting the caches
	//This intrinsic requires you to empty the multimedia state for the MMX register
	extern void _mm_stream_pi(__m64 * _P, __m64 _A);
	//返回为空，Stores the data in a to the address p without polluting the caches,
	//The address must be 16-byte aligned
	extern void _mm_stream_ps(float *, __m128 _A);
	//返回为空，Guarantees that every preceding store is globally visible 
	//before any subsequent store
	extern void _mm_sfence(void);
 
	/* Alternate intrinsic names definition */
	#define _mm_cvtss_si32    _mm_cvt_ss2si	
	#define _mm_cvtps_pi32    _mm_cvt_ps2pi
	#define _mm_cvttss_si32   _mm_cvtt_ss2si
	#define _mm_cvttps_pi32   _mm_cvtt_ps2pi
	#define _mm_cvtsi32_ss    _mm_cvt_si2ss
	#define _mm_cvtpi32_ps    _mm_cvt_pi2ps
	#define _mm_extract_pi16  _m_pextrw
	#define _mm_insert_pi16   _m_pinsrw
	#define _mm_max_pi16      _m_pmaxsw
	#define _mm_max_pu8       _m_pmaxub
	#define _mm_min_pi16      _m_pminsw
	#define _mm_min_pu8       _m_pminub
	#define _mm_movemask_pi8  _m_pmovmskb
	#define _mm_mulhi_pu16    _m_pmulhuw
	#define _mm_shuffle_pi16  _m_pshufw
	#define _mm_maskmove_si64 _m_maskmovq
	#define _mm_avg_pu8       _m_pavgb
	#define _mm_avg_pu16      _m_pavgw
	#define _mm_sad_pu8       _m_psadbw
	#define _mm_set1_ps       _mm_set_ps1
	#define _mm_load1_ps      _mm_load_ps1
	#define _mm_store1_ps     _mm_store_ps1
    ```

## 参考文献

1. [SSE指令集(1)-基础篇](https://www.jianshu.com/p/64ef4d304e17)
2. [基于SSE指令集的程序设计简介](https://blog.csdn.net/olncy/article/details/4084374)
3. [SSE Intrinsics各函数介绍](https://blog.csdn.net/fengbingchun/article/details/19293081)
4. [Intel SSE指令集](https://www.jianshu.com/p/d718c1ea5f22)
5. [SSE指令集学习：Compiler Intrinsic](https://www.cnblogs.com/wangguchangqing/p/5466301.html)
6. [C语言字节对齐问题详解](http://www.cnblogs.com/clover-toeic/p/3853132.html)
7. [在C/C++代码中使用SSE等指令集的指令(1)介绍](https://blog.csdn.net/gengshenghong/article/details/7007100)